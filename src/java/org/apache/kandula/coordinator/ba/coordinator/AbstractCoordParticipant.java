/*
 * Copyright 2007 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 *  @author Hannes Erven, Georg Hicker
 */

package org.apache.kandula.coordinator.ba.coordinator;

import java.rmi.RemoteException;

import javax.xml.namespace.QName;
import javax.xml.soap.Name;

import org.apache.axis.encoding.AnyContentType;
import org.apache.axis.message.addressing.EndpointReference;
import org.apache.kandula.coordinator.Callback;
import org.apache.kandula.coordinator.Coordinator;
import org.apache.kandula.coordinator.TimedOutException;
import org.apache.kandula.coordinator.ba.AbstractStateTransition;
import org.apache.kandula.coordinator.ba.State;
import org.apache.kandula.coordinator.ba.StateTransitionFault;
import org.apache.kandula.coordinator.ba.StateTransitionIgnore;
import org.apache.kandula.coordinator.ba.StateTransitionResend;
import org.apache.kandula.coordinator.ba.StateTransitionResendPreviousState;
import org.apache.kandula.coordinator.ba.StateTransitionState;
import org.apache.kandula.coordinator.ba.WrongMethodCallException;
import org.apache.kandula.wsba.ExceptionType;
import org.apache.kandula.wsba.NotificationType;
import org.apache.kandula.wsba.StateType;
import org.apache.kandula.wsba.StatusType;

/**
 * Instances of this class represent business activity participants that are registered
 * for a specific protocol in a given coordination context, as seen by the coordinator.
 * 
 * Participant instances on the "client" (participant) side are represented by @see org.apache.kandula.coordinator.ba.participant.AbstractParticipant and its
 * subclasses.
 * 
 * For each coordination protocol exists a subclass implementing providing
 * the specific behaviour required:
 * <ul>
 * <li>for the Participant Completion protocol, @see org.apache.kandula.coordinator.ba.coordinator.BAwPCCoordParticipant
 * <li>for the Coordinator Completion protocol, @see org.apache.kandula.coordinator.ba.coordinator.BAwCCCoordParticipant
 * </ul>
 * 
 * @author Hannes Erven, Georg Hicker (C) 2006
 * 
 */
public abstract class AbstractCoordParticipant implements Callback {

	/**
	 * The participant's state, as seen by the coordinator
	 */
	protected CoordinationState currState;

	/**
	 * My participant ID
	 */
	private final String myParticipantID;

	/**
	 * My participant's EPR (this is where the coordinator
	 * sends messages intended for the participant to)
	 */
	private final EndpointReference myParticipantEPR;

	/**
	 * My transaction context
	 */
	private final BACoordinator transactionContext;
	
	/**
	 * Matchcode provided by the initiator to identify the participant,
	 * unique in a given coordination context
	 */
	private final String matchcode;
	
	/**
	 * The default constructor. Use this to create a new Participant.
	 * EnpointReference and Protocoltype can not be changed afterwards.
	 * 
	 * This constructor is used by the BACoordinator when processing a register
	 * request, after all preconditions have been successfully checked and
	 * the participant is finally enrolled.
	 * (Actually, the BACoordinator invokes the constructor on one of the subclasses,
	 * which in turn pushes the request up here.)

	 * @param participantID 
	 * 			  This participant's participant ID, generated by the coordinator.
	 * @param participantEPR
	 *            The EndpointReference of the Participant.
	 * @param context
	 * 			  The transaction context the participant registered for.
	 * @param matchcodeP 
	 * 			  The matchcode the initiator assigned to this participant.
	 */
	protected AbstractCoordParticipant(
			final String participantID, 
			final EndpointReference participantEPR,
			final BACoordinator context,
			final String matchcodeP
	) {
		super();
		this.myParticipantID = participantID;
		this.myParticipantEPR = participantEPR;
		this.currState = new CoordinationState(getProtocolIdentifier());
		this.transactionContext = context;
		this.matchcode = matchcodeP;
	}

	/**
	 * Getter for the ProtocolType
	 * 
	 * @return The ProtocolType
	 */
	public abstract QName getProtocolIdentifier();

	/**
	 * Getter for the State the Participant is in.
	 * 
	 * @return The State
	 */
	public QName getCurrentState() {
		return this.currState.getCurrentState();
	}

	/**
	 * Gets the participant proxy for this participant.
	 * @return The participant proxy object.
	 */
	public abstract AbstractCoordParticipantProxy getParticipantProxy();
	
	/*
	 * Below are the methods that can be called on any WS-BA participant
	 * These methods are OUTGOING ! 
	 */
	
	/**
	 * Tells the participant to cancel
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellCancel() throws RemoteException{
		this.tell(State.MESSAGE_CANCEL);
	}

	/**
	 * Tells the participant to close
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellClose() throws RemoteException{
		this.tell(State.MESSAGE_CLOSE);
	}

	/**
	 * Tells the participant the current coordinator's state.
	 * 
	 * Attention: this method does *direct* calls to the participant's
	 * web service and skips the use of @see #tell(QName) and @see #tellAgain(QName),
	 * since state queries are always allowed and do not modify anything here.
	 * 
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellStatus() throws RemoteException {
		final StatusType st = new StatusType(
				StateType.fromValue(this.currState.getCurrentState()),
				null
		);
		this.getParticipantProxy().statusOperation(st);
	}

	/**
	 * Tell the participant to report its state
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellGetStatus() throws RemoteException {
		this.tell(State.MESSAGE_STATUS);
	}

	/**
	 * Tell the participant to compensate
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellCompensate() throws RemoteException {
		this.tell(State.MESSAGE_COMPENSATE);
	}

	/**
	 * Tell the participant that "fault" was accepted
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellFaulted() throws RemoteException {
		this.tell(State.MESSAGE_FAULTED);
	}

	/**
	 * Tell the participant that "exit" was accepted
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void tellExited() throws RemoteException {
		this.tell(State.MESSAGE_EXITED);
	}
	
	/*
	 * Here come the Callback implementation methods
	 */

	/**
	 * Get this participant's ID
	 * (Don't mix this one up with the matchcode: the participant ID is
	 *  created by the BACoordinator, the matchcode is assigned
	 *  by the initiator)
	 *  
	 *  @return This participant's id.
	 */
	public String getID() {
		return this.myParticipantID;
	}

	/**
	 * Handle fault
	 * @param code The fault code. 
	 */
	public void onFault(final Name code) {
		// TODO WSBA Handle faults
		if (code != null)
			code.toString();
	}

	/**
	 * Handle timeout
	 * @throws TimedOutException //TODO WSBA Handle timeouts
	 */
	public void timeout() throws TimedOutException {
		// TODO WSBA Handle faults
		
		if (false)
			throw new TimedOutException();
	}

	/**
	 * Get the participant's EPR. This EPR is used
	 * to send messages to the participant. 
	 * @return This participant's endpoint reference.
	 */
	public EndpointReference getEndpointReference() {
		return this.myParticipantEPR;
	}
	
	/**
	 * Accept an incoming message and do what is to be done.
	 * 
	 * @param messageType The incoming message's type
	 * @param params The params the message contained
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	protected void handleIncomingMessage(final QName messageType, final NotificationType params) throws RemoteException{
		try{
			final AbstractStateTransition transition =  this.currState.transistStateByMessage(messageType);
			System.out.println("Participant Incoming "+messageType+", Transition: "+transition);
			
			handleTransition(transition, params);
		}catch(RemoteException e){
			throw e;
		}catch(Exception e){
			throw Coordinator.INVALID_STATE_SOAP_FAULT() ;
		}
	}
	/**
	 * Accept an incoming message and do what is to be done.
	 * 
	 * @param messageType The incoming message's type
	 * @param params The params the message contained
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	protected void handleIncomingMessage(final QName messageType, final StatusType params) throws RemoteException{
		try{
			final AbstractStateTransition transition =  this.currState.transistStateByMessage(messageType);
			System.out.println("+ Transition: "+transition);
			
			handleTransition(transition, params);
		}catch(RemoteException e){
			throw e;
		}catch(Exception e){
			throw Coordinator.INVALID_STATE_SOAP_FAULT();
		}
	}
	/**
	 * Accept an incoming message and do what is to be done.
	 * 
	 * @param messageType The incoming message's type
	 * @param params The params the message contained
	 * @throws RemoteException A RemoteException that occured while sending a message to the participant.
	 */
	public void handleIncomingMessage(final QName messageType, final ExceptionType params) throws RemoteException{
		try{
			final AbstractStateTransition transition =  this.currState.transistStateByMessage(messageType);
			System.out.println("+ Transition: "+transition);
			
			handleTransition(transition, params);		
		}catch(RemoteException e){
			throw e;
		}catch(Exception e){
			throw Coordinator.INVALID_STATE_SOAP_FAULT() ;
		}
	}
	
	/**
	 * Handle a state transition. This method accepts a transition that was obtained by comparing
	 * the participant's current state and the incoming message against the protocol state table.
	 * 
	 * This method executes the actions given by the transition, e.g. moving into new state, notifying
	 * the initiator about that, throwing faults, sending acknownledgements etc.
	 * 
	 * 
	 * @param transition The transition object from State
	 * @param params Any parameters that the participant sent along
	 * @throws WrongMethodCallException 
	 * @throws RemoteException 
	 */
	private void handleTransition(
			final AbstractStateTransition transition, 
			final AnyContentType params
	) throws WrongMethodCallException, RemoteException{
		
		// Suppress compiler warning about unused parameter
		if (params != null)
			params.toString();
		
		// Check if there actually is a transition 
		if (transition == null)
			return;
		
		if (transition instanceof StateTransitionFault){
			final StateTransitionFault stf = (StateTransitionFault) transition;
			throw stf.getAxisFault();
			
		}else if(transition instanceof StateTransitionIgnore){
			// Ignore
			
		}else if (transition instanceof StateTransitionResend){
			final StateTransitionResend str = (StateTransitionResend) transition;
			this.tellAgain(str.getMessageToResend());
		
		}else if (transition instanceof StateTransitionResendPreviousState){
			final QName messageToResend = this.currState.getMessageForTransition(this.currState.getLastState(), this.currState.getSecondLastState());
			tellAgain(messageToResend);

		}else if (transition instanceof StateTransitionState){
			final StateTransitionState sts = (StateTransitionState) transition;
			System.out.println(" Participant changed state to "+sts.getState());
			this.transactionContext.handleStateTransition(this, sts.getState());

		}else{
			throw new IllegalArgumentException("Sorry, handleTransition does not know how to handle "+transition);
		}
	}
	
	/**
	 * Send some message to the participant. This method may only be used with participant operations
	 * that do not require arguments.
	 * This method ensures that the message to be sent is valid in the
	 * current state of the participant and throws an exception if not.
	 * If the message is OK, it is sent out and the associated state change is performed.
	 * 
	 * Calls @see #tellAgain(QName) to actually deliver the message.
	 * 
	 * This method is called from all the public tellXXX() methods in this class,
	 * e.g. @see #tellCancel().
	 * 
	 * @param message The message to send.
	 * @throws RemoteException If the participant did not accept the message
	 */
	protected synchronized void tell(final QName message) throws RemoteException{
		final QName stateBefore = this.currState.getCurrentState();
		
		if (this.currState.handleOutgoingMessage(message) ){
			// Message was OK and the new state has been set
		
			final QName stateAfter = this.currState.getCurrentState();
			
			if (stateBefore != null && (! stateBefore.equals(stateAfter))){
				this.transactionContext.handleStateTransition(this, stateAfter);
			}
			
			this.tellAgain(message);
		}else{
			// Error !
			throw State.GET_INVALID_STATE_SOAP_FAULT();
		}
	}
	/**
	 * Forward some message to the participant. This method may only be used with participant operations
	 * that do not require arguments.
	 * This method does no more than send the message out.
	 * @param message The message to send.
	 * @throws RemoteException If the participant did not accept the message
	 */
	protected void tellAgain(final QName message) throws RemoteException{
		final AbstractCoordParticipantProxy proxy =
			this.getParticipantProxy();

		if (State.MESSAGE_CANCEL.equals(message)){
			proxy.cancelOperation(null);
			
		}else if (State.MESSAGE_COMPENSATE.equals(message)){
			proxy.compensateOperation(null);

		}else if (State.MESSAGE_CLOSE.equals(message)){
			proxy.closeOperation(null);
			
		}else if (State.MESSAGE_EXITED.equals(message)){
			proxy.exitedOperation(null);
			
		}else if (State.MESSAGE_FAULTED.equals(message)){
			proxy.faultedOperation(null);
			
		}else if (State.MESSAGE_GETSTATUS.equals(message)){
			proxy.getStatusOperation(null);
			
		}else{
			throw new IllegalArgumentException("Sorry, cannot tell a participant "+message);
		}
	}

	/**
	 * Get the participant matchcode that was set for this participant.
	 * @return This participant's matchcode.
	 */
	public String getMatchcode() {
		return this.matchcode;
	}

	/**
	 * Return the result state of the participant, either
	 *  Completing
	 *  Canceling
	 *  Exiting
	 *  Faulting
	 * when ended;
	 * 
	 * Completed, when completed;
	 * 
	 * else Active .
	 * @return The state characterizing the participant's outcome best.
	 */
	public QName getResultState() {
		return this.currState.getResultState();
	}
}
